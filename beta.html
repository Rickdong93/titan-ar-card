<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>rniko 特製A賞特典</title>
    
    <!-- 1. 核心庫 -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@7.2.0/dist/aframe-extras.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        font-family: 'Microsoft JhengHei', sans-serif;
        background-color: black;
        touch-action: none; /* iOS 防滑動 */
      }

      /* --- 客製化 Loading 畫面 --- */
      #custom-loading {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #000;
        z-index: 99999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.8s ease-out;
      }
      
      /* GIF 容器 */
      .loading-gif-container {
        width: 150px;
        height: 150px;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        /* 新增：淡白色背景，防止 GIF 是黑色透明底導致看不見 */
        background-color: rgba(255, 255, 255, 0.05);
        border-radius: 15px;
        padding: 10px;
      }
      
      .loading-gif-container img {
        width: 100%;
        height: 100%;
        object-fit: contain; /* 保持比例 */
      }

      .loading-text {
        color: white;
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 30px;
        letter-spacing: 2px;
        text-align: center;
        text-shadow: 0 0 10px rgba(255,255,255,0.5);
      }

      /* 進度條區域 */
      .progress-wrapper {
        width: 200px;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
      }

      .progress-bar {
        width: 0%;
        height: 100%;
        background: #fff;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        transition: width 0.3s ease;
      }

      /* 開始按鈕 (預設隱藏，Loading 完顯示) */
      #start-btn {
        display: none;
        margin-top: 20px;
        padding: 12px 40px;
        background: white;
        color: black;
        border: none;
        border-radius: 30px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% { transform: scale(1); box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,255,255,0.8); }
        100% { transform: scale(1); box-shadow: 0 0 10px rgba(255,255,255,0.5); }
      }

      /* 隱藏 A-Frame 預設元件 */
      .a-enter-vr-button, .a-loader-title { display: none !important; }
    </style>

    <script>
      // --- 1. Loading 與 音效控制邏輯 ---
      document.addEventListener("DOMContentLoaded", function() {
        const scene = document.querySelector('a-scene');
        const loader = document.querySelector('#custom-loading');
        const progressBar = document.querySelector('.progress-bar');
        const progressWrapper = document.querySelector('.progress-wrapper');
        const startBtn = document.querySelector('#start-btn');
        
        // 音效元素
        const bgm = document.querySelector('#bgm-audio');
        
        // 模擬 Loading 進度 (為了視覺效果)
        let progress = 0;
        const interval = setInterval(() => {
          if (progress < 90) {
            progress += Math.random() * 5;
            progressBar.style.width = progress + '%';
          }
        }, 100);

        // 當 AR 系統準備就緒 (相機已開)
        scene.addEventListener('arReady', () => {
          clearInterval(interval);
          progressBar.style.width = '100%';
          
          // 稍微延遲後，隱藏進度條，顯示開始按鈕
          setTimeout(() => {
            progressWrapper.style.display = 'none'; // 隱藏進度條
            startBtn.style.display = 'block';     // 顯示開始按鈕
          }, 500);
        });

        // 點擊開始按鈕
        startBtn.addEventListener('click', () => {
          // 1. 播放音樂 (iOS 需要此點擊事件來解鎖 Audio)
          if(bgm) { 
            bgm.volume = 0.5; // 音量 50%
            // 嘗試播放，如果沒有檔案(catch)則忽略錯誤，不播放
            bgm.play().catch(e => {
              console.log("No BGM found or auto-play prevented. (Silent Mode)");
            });
          }

          // 2. 淡出 Loading 畫面
          loader.style.opacity = '0';
          setTimeout(() => {
            loader.style.display = 'none';
          }, 800);
        });

        // --- 2. 辨識成功時的邏輯 (播放音效 + 動畫) ---
        const target = document.querySelector('#my-image-target');
        const sfx = document.querySelector('#sfx-spawn');
        const model = document.querySelector('#avatar-model');

        target.addEventListener('targetFound', () => {
          // 播放登場音效 (如果有檔案)
          if(sfx) {
             sfx.currentTime = 0;
             sfx.play().catch(e => {
               // 靜默失敗：沒有檔案就不播
             });
          }
          
          // 重置並播放登場動畫 (彈出效果)
          model.removeAttribute('animation__spawn');
          model.setAttribute('animation__spawn', {
            property: 'scale',
            from: '0 0 0',
            to: '0.5 0.5 0.5', // 對應原本設定的大小
            dur: 800,
            easing: 'easeOutElastic'
          });
        });
      });

      // --- 3. 手勢偵測 (Gesture Detector) ---
      AFRAME.registerComponent("gesture-detector", {
        schema: { element: { default: "" } },
        init: function() {
          this.targetElement = this.data.element && document.querySelector(this.data.element);
          if (!this.targetElement) { this.targetElement = this.el; }
          this.internalState = { previousState: null };
          this.emitGestureEvent = this.emitGestureEvent.bind(this);
          this.targetElement.addEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.addEventListener("touchend", this.emitGestureEvent);
          this.targetElement.addEventListener("touchmove", this.emitGestureEvent);
        },
        remove: function() {
          this.targetElement.removeEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.removeEventListener("touchend", this.emitGestureEvent);
          this.targetElement.removeEventListener("touchmove", this.emitGestureEvent);
        },
        emitGestureEvent: function(event) {
          const currentState = this.getTouchState(event);
          const previousState = this.internalState.previousState;
          const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
          const gestureStarted = currentState && !gestureContinues;
          const gestureEnded = previousState && !gestureContinues;

          if (gestureEnded) { this.el.emit("gesture-end"); }
          if (gestureStarted) { this.el.emit("gesture-start"); }
          if (gestureContinues) {
            const detail = {
              positionChange: { 
                x: currentState.position.x - previousState.position.x, 
                y: currentState.position.y - previousState.position.y 
              },
              spreadChange: currentState.spread - previousState.spread,
              startSpread: currentState.startSpread,
              position: currentState.position
            };
            this.el.emit("gesture-move", detail);
          }
          this.internalState.previousState = currentState;
        },
        getTouchState: function(event) {
          if (event.touches.length === 0) { return null; }
          const touchList = [];
          for (let i = 0; i < event.touches.length; i++) { touchList.push(event.touches[i]); }
          const touchState = { touchCount: touchList.length };
          const centerPositionRawX = touchList.reduce((sum, touch) => sum + touch.clientX, 0) / touchList.length;
          const centerPositionRawY = touchList.reduce((sum, touch) => sum + touch.clientY, 0) / touchList.length;
          touchState.position = { x: centerPositionRawX, y: centerPositionRawY };
          touchState.spread = touchList.length > 1 ? Math.hypot(touchList[0].clientX - touchList[1].clientX, touchList[0].clientY - touchList[1].clientY) : 0;
          touchState.startSpread = this.internalState.previousState ? this.internalState.previousState.startSpread : touchState.spread;
          return touchState;
        }
      });

      // --- 4. 手勢操作 (Gesture Handler) - YXZ 順序優化版 ---
      AFRAME.registerComponent("gesture-handler", {
        schema: {
          enabled: { default: true },
          rotationFactor: { default: 5 },
          minScale: { default: 0.1 },
          maxScale: { default: 8.0 },
        },
        init: function() {
          this.handleScale = this.handleScale.bind(this);
          this.handleRotation = this.handleRotation.bind(this);
          this.initialScale = this.el.object3D.scale.clone();
          this.scaleFactor = 1;
          this.el.object3D.rotation.order = 'YXZ'; 

          this.el.sceneEl.addEventListener("gesture-move", this.handleRotation);
          this.el.sceneEl.addEventListener("gesture-move", this.handleScale);
        },
        remove: function() {
          this.el.sceneEl.removeEventListener("gesture-move", this.handleRotation);
          this.el.sceneEl.removeEventListener("gesture-move", this.handleScale);
        },
        handleRotation: function(event) {
          if (event.detail.spreadChange) { return; } 
          if (this.el.object3D.visible === false) return;

          this.el.object3D.rotation.x += event.detail.positionChange.y * this.data.rotationFactor * 0.005;
          this.el.object3D.rotation.y += event.detail.positionChange.x * this.data.rotationFactor * 0.005;
        },
        handleScale: function(event) {
          if (event.detail.spreadChange) {
            if (this.el.object3D.visible === false) return;
            const spreadChange = event.detail.spreadChange;
            this.scaleFactor *= 1 + (spreadChange / this.el.sceneEl.canvas.clientWidth) * 2; 
            this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
            this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
            this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
            this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
          }
        }
      });
    </script>
  </head>
  
  <body>
    <!-- 1. 客製化 Loading 介面 -->
    <div id="custom-loading">
      
      <!-- GIF 區域 -->
      <div class="loading-gif-container">
        <!-- 
          修正重點：
          1. onerror: 如果找不到 ./loading.gif，會自動換成貓咪 GIF。
          這能幫您確認是否為檔案上傳/路徑問題。
        -->
        <img src="./loading.gif" alt="Loading Animation" onerror="this.onerror=null; this.src='https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExM3pueXAxZnl4Y3R6Y3I4Z3R6Y3I4Z3R6eSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9cw/L0ZnJk3x7yT8G2yqX/giphy.gif';">
      </div>

      <div class="loading-text">rniko 特製A賞特典</div>
      
      <!-- 進度條 -->
      <div class="progress-wrapper">
        <div class="progress-bar"></div>
      </div>

      <!-- 開始按鈕 -->
      <button id="start-btn">開始體驗</button>
    </div>

    <!-- 2. AR 場景 -->
    <a-scene 
      mindar-image="imageTargetSrc: ./targets.mind; filterMinCF:0.0001; filterBeta: 0.001; uiScanning: no; uiLoading: no;" 
      loading-screen="enabled: false"
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false"
      gesture-detector>
      
      <a-assets>
        <a-asset-item id="avatarModel" src="./titan_model.glb"></a-asset-item>
        
        <!-- 音效資源 -->
        <!-- 
          已移除外部 CDN 連結，改為讀取本地檔案。
          如果您要播放音樂，請上傳:
          1. bgm.mp3 (背景音樂)
          2. spawn.mp3 (登場音效)
          如果沒有這些檔案，網頁將自動靜音，不會報錯。
        -->
        <audio id="bgm-audio" src="./bgm.mp3" loop="true" preload="auto"></audio>
        <audio id="sfx-spawn" src="./spawn.mp3" preload="auto"></audio>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-light type="ambient" intensity="1"></a-light>
      <a-light type="directional" position="1 1 1" intensity="1.5"></a-light>

      <a-entity mindar-image-target="targetIndex: 0" id="my-image-target">
        <a-gltf-model 
          id="avatar-model"
          src="#avatarModel" 
          position="0 0 0" 
          rotation="0 0 0" 
          scale="0.5 0.5 0.5" 
          class="clickable"
          animation-mixer="clip: *; loop: repeat;"
          gesture-handler> 
        </a-gltf-model>
      </a-entity>

    </a-scene>
  </body>
</html>