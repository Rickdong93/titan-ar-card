<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Titan AR - Full Control</title>
    
    <!-- 引入必要的 AR 庫 -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        /* 關鍵：禁止 iOS Safari 的預設滑動行為，讓手勢專注於模型 */
        touch-action: none; 
      }
      #ui-scanning {
        position: absolute; left: 0; top: 0; width: 100%; height: 100%;
        display: flex; align-items: center; justify-content: center;
        background: rgba(0, 0, 0, 0.0);
        pointer-events: none; 
        z-index: 999;
      }
      .scan-text {
        background: rgba(0, 0, 0, 0.6);
        color: white; padding: 10px 20px; border-radius: 20px;
        font-family: sans-serif;
        transition: opacity 0.5s;
      }
    </style>

    <script>
      // --- 1. 手勢偵測器 (負責計算手指移動與距離) ---
      AFRAME.registerComponent("gesture-detector", {
        schema: { element: { default: "" } },
        init: function() {
          this.targetElement = this.data.element && document.querySelector(this.data.element);
          if (!this.targetElement) { this.targetElement = this.el; }
          this.internalState = { previousState: null };
          this.emitGestureEvent = this.emitGestureEvent.bind(this);
          this.targetElement.addEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.addEventListener("touchend", this.emitGestureEvent);
          this.targetElement.addEventListener("touchmove", this.emitGestureEvent);
        },
        remove: function() {
          this.targetElement.removeEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.removeEventListener("touchend", this.emitGestureEvent);
          this.targetElement.removeEventListener("touchmove", this.emitGestureEvent);
        },
        emitGestureEvent: function(event) {
          const currentState = this.getTouchState(event);
          const previousState = this.internalState.previousState;
          const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
          const gestureStarted = currentState && !gestureContinues;
          const gestureEnded = previousState && !gestureContinues;

          if (gestureEnded) { this.el.emit("gesture-end"); }
          if (gestureStarted) { this.el.emit("gesture-start"); }
          if (gestureContinues) {
            const detail = {
              positionChange: { 
                x: currentState.position.x - previousState.position.x, 
                y: currentState.position.y - previousState.position.y 
              },
              spreadChange: currentState.spread - previousState.spread,
              startSpread: currentState.startSpread,
              position: currentState.position
            };
            this.el.emit("gesture-move", detail);
          }
          this.internalState.previousState = currentState;
        },
        getTouchState: function(event) {
          if (event.touches.length === 0) { return null; }
          const touchList = [];
          for (let i = 0; i < event.touches.length; i++) { touchList.push(event.touches[i]); }
          const touchState = { touchCount: touchList.length };
          const centerPositionRawX = touchList.reduce((sum, touch) => sum + touch.clientX, 0) / touchList.length;
          const centerPositionRawY = touchList.reduce((sum, touch) => sum + touch.clientY, 0) / touchList.length;
          touchState.position = { x: centerPositionRawX, y: centerPositionRawY };
          touchState.spread = touchList.length > 1 ? Math.hypot(touchList[0].clientX - touchList[1].clientX, touchList[0].clientY - touchList[1].clientY) : 0;
          touchState.startSpread = this.internalState.previousState ? this.internalState.previousState.startSpread : touchState.spread;
          return touchState;
        }
      });

      // --- 2. 手勢處理器 (接收訊號並改變模型) ---
      AFRAME.registerComponent("gesture-handler", {
        schema: {
          enabled: { default: true },
          rotationFactor: { default: 5 }, // 旋轉速度
          minScale: { default: 0.1 },     // 最小縮放
          maxScale: { default: 8.0 },     // 最大縮放 (稍微加大以便觀察)
        },
        init: function() {
          this.handleScale = this.handleScale.bind(this);
          this.handleRotation = this.handleRotation.bind(this);
          
          this.isVisible = false; 
          this.initialScale = this.el.object3D.scale.clone();
          this.scaleFactor = 1;

          // 監聽場景發出的 gesture-move 事件
          this.el.sceneEl.addEventListener("gesture-move", this.handleRotation);
          this.el.sceneEl.addEventListener("gesture-move", this.handleScale);
        },
        remove: function() {
          this.el.sceneEl.removeEventListener("gesture-move", this.handleRotation);
          this.el.sceneEl.removeEventListener("gesture-move", this.handleScale);
        },
        handleRotation: function(event) {
          // 只有當模型可見且是單指操作時才旋轉
          if (event.detail.spreadChange || !this.el.getAttribute('visible')) { return; }
          
          // X 軸旋轉 (上下滑動)
          this.el.object3D.rotation.x += event.detail.positionChange.y * this.data.rotationFactor * 2 * Math.PI / 1000;
          // Y 軸旋轉 (左右滑動)
          this.el.object3D.rotation.y += event.detail.positionChange.x * this.data.rotationFactor * 2 * Math.PI / 1000;
        },
        handleScale: function(event) {
          // 只有當模型可見且有雙指縮放變化時才縮放
          if (event.detail.spreadChange && this.el.getAttribute('visible')) {
            const spreadChange = event.detail.spreadChange;
            // 調整縮放公式，增加靈敏度
            this.scaleFactor *= 1 + (spreadChange / this.el.sceneEl.canvas.clientWidth) * 2; 
            this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
            
            this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
            this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
            this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
          }
        }
      });

      // --- 3. 持久化邏輯 (Persistence) ---
      // 確保模型在圖片移開後不會消失
      AFRAME.registerComponent('persistent-tracker', {
        schema: {
          target: {type: 'selector'} 
        },
        init: function() {
          this.isTracking = false;
          this.targetEl = this.data.target; 
          this.container = this.el; 

          // 初始隱藏
          this.container.setAttribute('visible', false);
          
          const scanText = document.querySelector('.scan-text');

          // --- 發現目標 ---
          this.targetEl.addEventListener('targetFound', () => {
            console.log("FOUND: Syncing position");
            this.isTracking = true;
            this.container.setAttribute('visible', true);
            
            // 重置模型動畫
            const model = this.container.querySelector('a-gltf-model');
            if(model) {
              model.setAttribute('animation-mixer', {clip: '*', loop: 'repeat'});
              model.setAttribute('visible', true); // 雙重保險
            }

            if(scanText) {
                scanText.innerText = "模型已鎖定，可自由移動視角";
                scanText.style.opacity = '0'; // 淡出文字
            }
          });

          // --- 目標丟失 ---
          this.targetEl.addEventListener('targetLost', () => {
            console.log("LOST: Stopping sync, keeping model visible");
            this.isTracking = false;
            // 重點：這裡絕對不執行 setAttribute('visible', false)
            // 讓模型停留在最後一次 tick 更新的位置
          });
        },
        tick: function() {
          // 只有在「真正掃描到圖片」的時候，才把模型的位置吸附到圖片上
          if (this.isTracking && this.targetEl.object3D.visible) {
            const targetObject = this.targetEl.object3D;
            const containerObject = this.container.object3D;

            // 持續同步位置與旋轉
            containerObject.position.copy(targetObject.position);
            containerObject.quaternion.copy(targetObject.quaternion);
          }
        }
      });
    </script>
  </head>
  
  <body>
    <!-- 場景設定 -->
    <a-scene 
      mindar-image="imageTargetSrc: ./targets.mind; filterMinCF:0.0001; filterBeta: 0.001; uiScanning: no;" 
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false" 
      device-orientation-permission-ui="enabled: false"
      gesture-detector> <!-- 啟用手勢偵測 -->
      
      <a-assets>
        <a-asset-item id="avatarModel" src="./titan_model.glb"></a-asset-item>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <!-- UI 提示 -->
      <div id="ui-scanning"><div class="scan-text">請掃描圖片生成模型</div></div>

      <!-- 
        MindAR 錨點 (隱形) 
        只用來獲取座標，不放模型
      -->
      <a-entity mindar-image-target="targetIndex: 0" id="target-anchor"></a-entity>

      <!-- 
        模型容器 (獨立於 MindAR Target 之外)
        persistent-tracker 負責控制它何時跟隨 anchor
      -->
      <a-entity id="avatar-container" persistent-tracker="target: #target-anchor">
        
        <!-- 
           實際模型 
           gesture-handler 放在這裡，控制旋轉與縮放
        -->
        <a-gltf-model 
          id="avatar-model"
          src="#avatarModel" 
          position="0 0 0" 
          rotation="0 0 0" 
          scale="0.5 0.5 0.5" 
          class="clickable"
          gesture-handler> 
        </a-gltf-model>

      </a-entity>

    </a-scene>
  </body>
</html>