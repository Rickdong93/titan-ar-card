<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Titan AR Card - Fixed</title>
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
    
    <style>
      /* === 修正重點 1: 完美全螢幕 (解決右側白條) === */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* 禁止捲動，防止出現白邊 */
        background-color: black; /* 預防任何縫隙出現白色 */
      }
      
      /* 強制視訊滿版 */
      video {
        position: absolute;
        top: 0;
        left: 0;
        z-index: -2 !important;
        width: 100vw !important;
        height: 100vh !important;
        object-fit: cover !important;
      }

      /* 修正 Canvas 層級 */
      .a-canvas {
        width: 100% !important;
        height: 100% !important;
        position: absolute !important;
        top: 0;
        left: 0;
        z-index: 1 !important;
      }
      
      /* 隱藏 VR 按鈕 */
      .a-enter-vr-button { display: none; }
    </style>

    <script>
      // === 1. 手勢偵測 (Gesture Detector) ===
      AFRAME.registerComponent("gesture-detector", {
        schema: { element: { default: "" } },
        init: function() {
          this.targetElement = this.data.element && document.querySelector(this.data.element);
          if (!this.targetElement) { this.targetElement = this.el; }
          this.internalState = { previousState: null };
          this.emitGestureEvent = this.emitGestureEvent.bind(this);
          this.targetElement.addEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.addEventListener("touchend", this.emitGestureEvent);
          this.targetElement.addEventListener("touchmove", this.emitGestureEvent);
        },
        remove: function() {
          this.targetElement.removeEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.removeEventListener("touchend", this.emitGestureEvent);
          this.targetElement.removeEventListener("touchmove", this.emitGestureEvent);
        },
        emitGestureEvent: function(event) {
          const currentState = this.getTouchState(event);
          const previousState = this.internalState.previousState;
          const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
          const gestureEnded = previousState && !gestureContinues;
          const gestureStarted = currentState && !gestureContinues;
          if (gestureEnded) { this.el.emit("gesture-end"); }
          if (gestureStarted) { this.el.emit("gesture-start"); }
          if (gestureContinues) {
            const detail = {
              positionChange: { x: currentState.position.x - previousState.position.x, y: currentState.position.y - previousState.position.y },
              spreadChange: currentState.spread - previousState.spread,
              startSpread: currentState.startSpread,
              position: currentState.position
            };
            this.el.emit("gesture-move", detail);
          }
          this.internalState.previousState = currentState;
        },
        getTouchState: function(event) {
          if (event.touches.length === 0) { return null; }
          const touchList = [];
          for (let i = 0; i < event.touches.length; i++) { touchList.push(event.touches[i]); }
          const touchState = { touchCount: touchList.length };
          const centerPositionRawX = touchList.reduce((sum, touch) => sum + touch.clientX, 0) / touchList.length;
          const centerPositionRawY = touchList.reduce((sum, touch) => sum + touch.clientY, 0) / touchList.length;
          touchState.position = { x: centerPositionRawX, y: centerPositionRawY };
          touchState.spread = touchList.length > 1 ? Math.hypot(touchList[0].clientX - touchList[1].clientX, touchList[0].clientY - touchList[1].clientY) : 0;
          touchState.startSpread = this.internalState.previousState ? this.internalState.previousState.startSpread : touchState.spread;
          return touchState;
        }
      });

      // === 2. 手勢操作器 (Gesture Handler) - 支援 X/Y 軸旋轉與縮放 ===
      AFRAME.registerComponent("gesture-handler", {
        schema: {
          enabled: { default: true },
          rotationFactor: { default: 5 },
          minScale: { default: 0.1 },
          maxScale: { default: 3.0 },
        },
        init: function() {
          this.handleScale = this.handleScale.bind(this);
          this.handleRotation = this.handleRotation.bind(this);
          this.initialScale = this.el.object3D.scale.clone();
          this.scaleFactor = 1;
          this.el.sceneEl.addEventListener("gesture-move", this.handleRotation);
          this.el.sceneEl.addEventListener("gesture-move", this.handleScale);
        },
        remove: function() {
          this.el.sceneEl.removeEventListener("gesture-move", this.handleRotation);
          this.el.sceneEl.removeEventListener("gesture-move", this.handleScale);
        },
        handleRotation: function(event) {
          if (event.detail.spreadChange) { return; } 
          // 左右滑動 -> Y 軸轉
          this.el.object3D.rotation.y += event.detail.positionChange.x * this.data.rotationFactor * 2 * Math.PI / 1000;
          // 上下滑動 -> X 軸轉
          this.el.object3D.rotation.x += event.detail.positionChange.y * this.data.rotationFactor * 2 * Math.PI / 1000;
        },
        handleScale: function(event) {
          if (event.detail.spreadChange) {
            const spreadChange = event.detail.spreadChange;
            this.scaleFactor *= 1 + spreadChange / this.el.sceneEl.canvas.clientWidth;
            this.scaleFactor = Math.min(Math.max(this.scaleFactor, this.data.minScale), this.data.maxScale);
            this.el.object3D.scale.x = this.scaleFactor * this.initialScale.x;
            this.el.object3D.scale.y = this.scaleFactor * this.initialScale.y;
            this.el.object3D.scale.z = this.scaleFactor * this.initialScale.z;
          }
        }
      });

      // === 3. 穩定版模型同步器 (Stable Synchronizer) ===
      AFRAME.registerComponent("simple-sync", {
        schema: {
          target: { type: 'selector' },
          model: { type: 'selector' }
        },
        init: function () {
          this.isTracking = false;
          
          // 找到卡片時
          this.data.target.addEventListener("targetFound", () => {
            this.isTracking = true;
            // 只要找到一次，就永久顯示
            this.data.model.setAttribute("visible", true);
          });

          // 丟失卡片時
          this.data.target.addEventListener("targetLost", () => {
            this.isTracking = false;
            // 這裡不做任何事，保持 visible=true (達成持久化)
          });
        },
        tick: function () {
          // 只有在「當下正在追蹤」時，才更新位置
          // 這樣卡片移開後，模型會停留在「最後一次看到卡片」的位置
          if (this.isTracking && this.data.target && this.data.model) {
            const targetObj = this.data.target.object3D;
            const modelObj = this.data.model.object3D;
            modelObj.position.copy(targetObj.position);
            modelObj.quaternion.copy(targetObj.quaternion);
          }
        }
      });
    </script>
  </head>
  
  <body>
    <a-scene 
      mindar-image="imageTargetSrc: ./targets.mind; filterMinCF:0.0001; filterBeta: 0.001; uiLoading: yes; uiScanning: yes;" 
      color-space="sRGB" 
      renderer="colorManagement: true, physicallyCorrectLights" 
      vr-mode-ui="enabled: false"